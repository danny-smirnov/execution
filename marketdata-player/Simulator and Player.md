# Устойство проигрывателя
Пусть в базе данных хранятся все события стакана, упорядоченные по возрастанию времененной метки. 

Проигрыватель будет получать на вход объект "итератор", благодаря которому проигрыватель будет инкрементально получать события из базы данных за определенный промежуток времени. Старт проигрывателя будем начинать со Snapshot/Depth, на который будут накладываться последовательно полученные события. 

Внутри проигрывателя будет поле хранящее текущее время симуляции, которое будет обновляться при каждом получении события специальным методом, внутри которого можно будет закладывать логику для обработки временной характеристики. Все обработки событий будут начинаться с данного метода.

# Устройство симулятора
Суть симулятора для execution problem в симулировании MarketOrder в определенные моменты времени (считаем, что в стакан вставать не будем). 

Пусть мы знаем все характеристики требуемой заяви, соответвенно, когда симулятор получаем первое событие с временной меткой позже чем наше, то в обработчике времени происходит вызов обработчика нашего собития через соответвующую функцию симулятора, которая на вход получает необходимые данные от проигрывателя, а после ожидающего исполнения реального события. 

В случае, если симулятору необходимо дополнительно обрабатывать сущетсвующие события (для подсчета различных характеристик), то обработчике времени при получении события также вызывает соответствующий метод симулятора с необходимыми данными, таким образом все необходимые характеристики стакана для симуляции хранятся внутри симулятора.

## Симуляция MarketOrder
При имеющейся модели стакана просимулировать MarketOrder довольно просто, так как мы знаем предполагаемое значение ценовых уровней и объемов на них. 

Если нас интересует количество товара `T` получаемого за определенную сумму `M` в данный момент времени, то оно будет определяться следующей формулой:

`T = min{M / p_1, x_1} + max{min{(M - x_1 * p_1) / p_2, x_2}, 0} + ...`, где `x_i, p_i` - объем и цена `i`-того уровня. 

Если же нас интересует минимальная сумма `M` для покупки товара объема `T` в данный момент времени, то она определяется как:

`M = min{x_1 - T, T} * p_1 + max{min{x_2 - (T - x_1), (T - x_1)}, 0} * p_2 + ...`.

Если учесть, что объемы наших запросов будут не очень большими, то ,в основном, сделки будут происходить на лучшем уровне, тогда для получения данных симуляции в обоих случаях достаточно знать только цену лучшего уровня, для оценки которой на малом промежутке времени достаточно следить лишь за трейдами, периодически обновляя информацию о лучших уровнях используя Depth.